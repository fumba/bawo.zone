

<!DOCTYPE html>
<html lang="en">

<head>
  
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title> js/core/Board.ts</title>

  <script src="https://cdn.jsdelivr.net/gh/google/code-prettify@master/loader/run_prettify.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <script src="./build/entry.js"></script>
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->
  <link href="https://fonts.googleapis.com/css?family=Roboto:100,400,700|Inconsolata,700" rel="stylesheet">
  <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.6.3/css/all.css" integrity="sha384-UHRtZLI+pbxtHCWp1t77Bi1L4ZtiqrqD80Kn4Z8NTSRyMA2Fd33n5dQ8lWUE00s/" crossorigin="anonymous">
  <link type="text/css" rel="stylesheet" href="https://jmblog.github.io/color-themes-for-google-code-prettify/themes/tomorrow-night.min.css">
  <link type="text/css" rel="stylesheet" href="styles/app.min.css">
  <link type="text/css" rel="stylesheet" href="styles/iframe.css">
  <link type="text/css" rel="stylesheet" href="">
  <script async defer src="https://buttons.github.io/buttons.js"></script>

  
</head>



<body class="layout small-header">
    <div id="stickyNavbarOverlay"></div>
    

<div class="top-nav">
    <div class="inner">
        <a id="hamburger" role="button" class="navbar-burger" aria-label="menu" aria-expanded="false">
            <span aria-hidden="true"></span>
            <span aria-hidden="true"></span>
            <span aria-hidden="true"></span>
        </a>
        <div class="logo">
            
             
                <a href="index.html">
                    <h1 class="navbar-item">bawo.zone</h1>
                </a>
            
        </div>
        <div class="menu">
            
            <div class="navigation">
                <a
                    href="index.html"
                    class="link"
                >
                    API Documentation
                </a>
                
                
                
            </div>
        </div>
    </div>
</div>
    <div id="main">
        <div
            class="sidebar "
            id="sidebarNav"
        >
            
            <nav>
                
                    <h2><a href="index.html">Documentation</a></h2><div class="category"><h3>Classes</h3><ul><li><a href="AppConstants.html">AppConstants</a></li><li><a href="Hole.html">Hole</a></li><li><a href="Move.html">Move</a></li><li><a href="Player.html">Player</a></li><li><a href="PlayerBoardHoles.html">PlayerBoardHoles</a></li><li><a href="ScoreItem.html">ScoreItem</a></li></ul><h3>Global</h3><ul><li><a href="global.html#fs">fs</a></li><li><a href="global.html#MoveDirection">MoveDirection</a></li><li><a href="global.html#PlayerSide">PlayerSide</a></li></ul></div>
                
            </nav>
        </div>
        <div class="core" id="main-content-wrapper">
            <div class="content">
                <header class="page-title">
                    <p>Source</p>
                    <h1>js/core/Board.ts</h1>
                </header>
                



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>import Hole from "./Hole";
import Player from "./Player";
import PlayerSide from "./PlayerSide";
import Rules from "./Rules";
import MtajiModeRules from "./MtajiModeRules";
import PlayerBoardHoles from "./PlayerBoardHoles";
import AppConstants from "./AppConstants";
import Logger from "../../helpers/Logger";
import Move from "./Move";
import MoveDirection from "./MoveDirection";

/*
 * bawo.zone - &lt;a href="https://bawo.zone">https://bawo.zone&lt;/a>
 * &lt;a href="https://github.com/fumba/bawo.zone">https://github.com/fumba/bawo.zone&lt;/a>
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Board {
  private currentPlayer: Player;
  public readonly bottomPlayer: Player;
  public readonly topPlayer: Player;
  private readonly rules: Rules;

  constructor(rules?: Rules) {
    this.bottomPlayer = new Player(PlayerSide.Bottom);
    this.topPlayer = new Player(PlayerSide.Top);
    if (!rules) {
      this.rules = new MtajiModeRules();
    }
    this.rules.validate();

    // initialise player board holes
    [this.topPlayer, this.bottomPlayer].forEach((player) => {
      const playerInitSeedConfig: Array&lt;number> = this.rules
        .initialSeedForPlayerRows()
        .get(player.side);
      const playerBoardHoles: PlayerBoardHoles = new PlayerBoardHoles(player);
      for (let index = 0; index &lt; AppConstants.NUM_PLAYER_HOLES; index++) {
        playerBoardHoles.insertAtEnd(playerInitSeedConfig[index]);
      }
    });

    //set current player
    this.currentPlayer = this.topPlayer;
    this.updateMovesStatus();
  }

  /**
   * Extract the opposing enemy hole from the players front row.
   * This is hole from which the current player will be capturing seeds from.
   *
   * @param hole Hole from which the opposing enemy hole is to be retrieved from.
   * @returns Opposing enemy hole.
   */
  public adjacentOpponentHole(hole: Hole): Hole {
    if (hole.isInFrontRow()) {
      const oppossingId: number = 15 - hole.id;
      const opponentPlayer: Player = this.getOpponentPlayer(hole.player);
      return opponentPlayer.boardHoles.getHoleWithID(oppossingId);
    }
    throw new Error(
      `Attempted to retrieve adjacent opponent hole from a hole that is not in the front row | input: ${hole.id}`
    );
  }

  /**
   * Update the move status for all the holes on the board.
   *
   * Move Status can be one of the following:
   *
   * CLOCKWISE
   *
   * ANTI_CLOCKWISE
   *
   * BOTH - Both clockwise and anti-clockwise moves are allowed.
   *
   * LOCKED - A valid move cannot be made from the hole.
   *
   * UNAUTHORISED - The hole does not belong to the current player.
   */
  private updateMovesStatus(): void {
    for (const hole of this.topPlayer.boardHoles) {
      this.updateMoveStatusForHole(hole);
    }
    for (const hole of this.bottomPlayer.boardHoles) {
      this.updateMoveStatusForHole(hole);
    }
  }

  /**
   * Updates the move status for the specified hole.
   *
   * @param hole The Hole on will be performed on.
   */
  private updateMoveStatusForHole(hole: Hole): void {
    // Update status only if the current player is authorized to make a move
    // on the hole.
    if (
      hole.player == this.currentPlayer &amp;&amp;
      this.currentPlayer.numSeedsInHand == 0
    ) {
      const clockwiseMove: Move = new Move(this, hole, MoveDirection.Clockwise);
      const antiClockwiseMove: Move = new Move(
        this,
        hole,
        MoveDirection.AntiClockwise
      );
      const isValidClockwiseMove: boolean = this.isValidMove(clockwiseMove);
      const isValidAntiClockwiseMove: boolean =
        this.isValidMove(antiClockwiseMove);
      if (isValidClockwiseMove &amp;&amp; isValidAntiClockwiseMove) {
        hole.moveStatus = MoveDirection.Both;
      } else if (isValidClockwiseMove) {
        hole.moveStatus = MoveDirection.Clockwise;
      } else if (isValidAntiClockwiseMove) {
        hole.moveStatus = MoveDirection.AntiClockwise;
      } else {
        hole.moveStatus = MoveDirection.Locked;
      }
    } else {
      // holes that do not belong to the current player are set as
      // unauthorized.
      hole.moveStatus = MoveDirection.UnAuthorised;
    }
  }

  /**
   * Check if a move valid. GameRules implementation is used to make this
   * decision.
   *
   * @param move The move whose validity is to be checked.
   * @returns boolean {@code true} if the move is valid.
   */
  public isValidMove(move: Move): boolean {
    //check move integrity
    if (move == null) {
      throw new Error("Move is null.");
    }
    // Check if the current player is allowed to make move.
    if (this.currentPlayer == null) {
      throw new Error("Current player is not specified.");
    }
    if (this.currentPlayer != move.hole.player) {
      throw new Error(
        "Player " +
          this.currentPlayer +
          " is not allowed to make a move on hole " +
          move.hole.toString()
      );
    }
    if (move.hole == null) {
      throw new Error("Move is required to have a starting hole specified.");
    }
    if (move.direction == null) {
      throw new Error("Move is required to have its direction specified.");
    }

    return this.rules.isValidMove(move);
  }

  public switchPlayers(): void {
    if (
      this.topPlayer.numSeedsInHand == 0 &amp;&amp;
      this.bottomPlayer.numSeedsInHand == 0
    ) {
      this.currentPlayer = this.getOpponentPlayer(this.currentPlayer);
    } else {
      throw new Error(
        "Cannot assign players while player(s) has(ve) seed(s) in hand: \n" +
          this.topPlayer +
          "\n" +
          this.bottomPlayer
      );
    }
    this.updateMovesStatus();
    Logger.info(
      "Players Switched. Current player info: \n" +
        this.currentPlayer.toString(),
      Board.name
    );
  }

  //TODO
  public static loadState(
    topPlayerSeedArrangement: Array&lt;number>,
    btmPlayerSeedArrangement: Array&lt;number>
  ): Board {
    const board: Board = new Board();
    //update hole seed counts for top player
    if (topPlayerSeedArrangement) {
      //TODO validate length - 16
      Logger.info(
        `Updating seed configuration for bottom player to ${topPlayerSeedArrangement}`,
        this.name
      );
      for (let id = 0; id &lt; AppConstants.NUM_PLAYER_HOLES; id++) {
        board.topPlayer.boardHoles.getHoleWithID(id).numSeeds =
          topPlayerSeedArrangement[id];
      }
    }
    //update hole seed counts for bottom player
    if (btmPlayerSeedArrangement) {
      //TODO validate length - 16
      Logger.info(
        `Updating seed configuration for bottom player to ${btmPlayerSeedArrangement}`,
        this.name
      );
      for (let id = 0; id &lt; AppConstants.NUM_PLAYER_HOLES; id++) {
        board.bottomPlayer.boardHoles.getHoleWithID(id).numSeeds =
          btmPlayerSeedArrangement[id];
      }
    }
    return board;
  }

  /**
   * Retrieves all the valid moves for a player.
   *
   * @param player
   *                   The Player who is requesting the list of valid moves.
   * @returns A list of moves that are valid. These moves can be executed on
   *         gameboard.
   */
  public getAllAvailableValidMoves(player: Player): Array&lt;Move> {
    this.updateMovesStatus();
    const moves: Array&lt;Move> = [];
    for (const hole of player.boardHoles) {
      if (
        hole.moveStatus == MoveDirection.Clockwise ||
        hole.moveStatus == MoveDirection.AntiClockwise
      ) {
        moves.push(new Move(this, hole, hole.moveStatus));
      } else if (hole.moveStatus == MoveDirection.Both) {
        moves.push(new Move(this, hole, MoveDirection.Clockwise));
        moves.push(new Move(this, hole, MoveDirection.AntiClockwise));
      }
    }
    return moves;
  }

  public toString(): string {
    this.updateMovesStatus();
    let buffer = "\n".concat(this.topPlayer.boardHoles.toString());
    buffer = buffer.concat(this.bottomPlayer.boardHoles.toString());
    return buffer.replace(/\n$/, ""); //remove newline at the end
  }

  public runSimulation(): void {
    Logger.info(`initial board state : ${this}`, Board.name);
    this.switchPlayers();
    Logger.info(`state after switching players : ${this}`, Board.name);
  }
  /**
   * Retrieves the opponent player for the current player.
   *
   * @param player Player whose opponent is to be determined.
   * @returns
   */
  private getOpponentPlayer(player: Player): Player {
    return player.isOnTopSide() ? this.bottomPlayer : this.topPlayer;
  }
}
export default Board;
</code></pre>
        </article>
    </section>




            </div>
            
            <footer class="footer">
                <div class="content has-text-centered">
                    <p>Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.6.7</a></p>
                    <p class="sidebar-created-by">
                        <a href="https://github.com/SoftwareBrothers/better-docs" target="_blank">BetterDocs theme</a> provided with <i class="fas fa-heart"></i> by 
                        <a href="http://softwarebrothers.co" target="_blank">SoftwareBrothers - JavaScript Development Agency</a>
                    </p>
                </div>
            </footer>
            
        </div>
        <div id="side-nav" class="side-nav">
        </div>
    </div>
<script src="scripts/app.min.js"></script>
<script>PR.prettyPrint();</script>
<script src="scripts/linenumber.js"> </script>

</body>
</html>
